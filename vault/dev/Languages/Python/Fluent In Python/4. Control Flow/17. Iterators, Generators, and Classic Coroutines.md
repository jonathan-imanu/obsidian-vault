# Iterators

Python automatically calls `iter(x)` when trying to iterate over a function. The `iter` built-in checks if `__iter__` is implemented, if not then gets creates an iterator with `__getitem__`. If that isn't implemented, then we get a type error.

```python
def d6():
	return randint(1, 6)

d6_iter = iter(d6, 1) # 1 is sentenial val, stop when 1 is reached
for roll in d6_iter:
	pass

# d6_iter is useless here
# the iterator is exhausted 
```

## Iterators vs Iterables

Iterables have an `__iter__` method that instantiates a new iterator every time. Iterators implement a `__next__` method that returns individual items, and an `__iter__` method that returns `self`.

**Iterables produce iterators**
# Generators

Any Python function that has the `yield` keyword in its body is a generator function: a function which, when called, returns a generator object. 

In other words, a generator function is a generator factory.

*Generator objects implement the Iterator interface, so they are also iterable.* The return statement in the body of a generator function causes `StopIteration` to be raised by the generator object

### `yield from`

Allows us to yield values produced by another generator.

```python 
def generate(n: int, i: int, cur: list[int]):
    if i == n:
        yield cur
        return

    for x in generate(n, i + 1, cur + [i]):
        yield x

    for x in generate(n, i + 1, cur + [i + 1]):
        yield x

# Becomes the cleaner and simplier:

def generate(n: int, i: int, cur: list[int]):
    if i == n:
        yield cur
        return

    yield from generate(n, i + 1, cur + [i])
    yield from generate(n, i + 1, cur + [i + 1])
```

**Google Interview Lesson:**

As the above example demonstrates, backtracking or other recursive functions where in which we don't care about the complete result set are excellent cases for which to use generators.

At the end of the day, generators are just special iterators that:

- produce values lazily
- have execution state suspended and resumed between yields

The key consequences of this are:

1. Only the **current call stack**
2. Only the **current path**
3. Only the **current iterator states**

# Classic Coroutines / Generator-Based Coroutines

**Coroutine General Definition:** A coroutine is a function-like routine that can pause its execution (yield) at specific points, preserving its state, and then be resumed later from that exact spot.

A coroutine is really a generator function, created with the yield keyword in its body. And a coroutine object is physically a generator object.

Typing of a coroutine: `Coroutine[YieldType, SendType, ReturnType]`

Probably worth fully reading https://peps.python.org/pep-0342/ if we ever encounter this in the wild.

With these generator based coroutines, we'll have to call `next()` first.
