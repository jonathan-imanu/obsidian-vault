
> **Python variables are names bound to objects.**
### == & is

- `==` is comparison on values and `is` is based on identities
	- `a == b` will follow the following steps:
		1. Call `a.__eq__(b)`
		2. If that returns NotImplemented, then call `b.__eq__(a)`
		3. If that also returns NotImplemented, then `a is b`
	- **This is fundamentally different than C or Go!** Equality checks with == work on primitive raw values
#### Call by Sharing

The only mode of parameter passing in Python is call by sharing. Call by sharing means that the parameters inside the function become aliases of the actual arguments.
###### ***Mutable Types as Parameter Defaults***

DO NOT DO.

```python
class Dummy:
	def __init__(self, passengers=[]): # 
		self.passengers = passengers
		
dummy1 = Dummy()
dummy2 = Dummy()

# id(dummy1.passengers) == id(dummy2.passengers) is True !!!!!
```

Default argument expressions are evaluated **once**, at **function definition time**, and the resulting objects are stored on the function object. They are **not** re-created each time the function is called.

#### An aside on `del`

A statement **NOT** a function that deletes references **NOT** objects

#### Interning

The sharing of string literals is an optimization technique called interning. 

CPython uses a similar technique with small integers to avoid unnecessary duplication of num‐ bers that appear frequently in programs like 0, 1, –1, etc. 

Note that CPython does not intern all strings or integers, and the criteria it uses to do so is an undocumented implementation detail.

**Example Code:**

```python
x = 3
y = x
print(f"x: {id(x)}, y:{id(y)}") # x,y have same ids, expected
x = 4
y = 4
print(f"x: {id(x)}, y:{id(y)}") # x,y have same ids although different than before, INTERNING!
x = 4
y = 5
print(f"x: {id(x)}, y:{id(y)}") # x,y have diff ids! BUT id(x) is same as before
```

