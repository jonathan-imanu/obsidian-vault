# Decorators

A decorator is just a callable that takes another function as an argument. This decorator may perform some processing with the decorated function, and returns it or replaces it with another function or callable object.

**They are just syntactic sugar**. Any decorator is equivalent to just doing:

```python 
@alpha
@beta 
def factorial(n): 
	return 1 if n < 2 else n*factorial(n-1)
	
# Is the same as the below:

def factorial(n): 
	return 1 if n < 2 else n*factorial(n-1) 

factorial = alpha(beta(factorial))
```

**Run at import time:** A key feature of decorators is that they run right after the decorated function is defined. That is usually at **import time** (i.e., when a module is loaded by Python).
# Closures

A function that **retains the bindings of the free variables that exist when the function is defined**, so that they can be used later when the function is invoked and the defining scope is no longer available.

```python
def make_averager(): 
	# series is a free variable
	# It isn't bound in the local scope
	series = [] 
	
	
	def averager(new_value): 
		# Why don't we need nonlocal here?
		# ANS: series is a list -> mutable!
		series.append(new_value) 
		total = sum(series) 
		return total / len(series)
		 
	return averager
```
#### Using `nonlocal`

Declare a variable as a free variable even when it is assigned within the function. If a new value is assigned to a nonlocal variable, the binding stored in the closure is changed.

For an example, consider this more efficient impl. of `averager`:

```python

def make_averager():
	count = total = 0
	
	def averager(new_value):
		nonlocal count, total
		total += new_value
		count += 1
		return total / count
	
	return averager
```

#### `from functools import singledispatch`

Is the closest thing we have to operator overloading in Python


