**Object Files**: Just machine code and some other stuff. The key is that it is isn't executable until it has been linked.

**Obvious**: .exe's aren't portable

```cpp
namespace::func // means the func following the :: can be found in the namespace namespace

std::cout // a real ex

using namespace std
cout
```

**Unlike Go,** C++ allows overloading, yields an error if there are ambiguities around which function to call; IE one is not better than the other

**Oddity**: A significant difference from most languages is that we can use `{}` for initialization of variables:

```cpp
int infoLost = 3.2
int errors {3.2} // error: floating-point to integer conversion
```

`=` seems to remain for C++ to C compatibility only and is not recommended

The `auto` keyword is a lot like `:=` in Go: let the initializer figure out what type this is. Like Go `:=` in Go use auto unless:

1. Precision (int32 vs int64) matters
2. We want the type to be obvious for readability

### constexpr

**â€œIf the arguments are known at compile time, please evaluate at compile time. Otherwise, run it at runtime**"

A big performance win.
### References

Like a pointer but we can't refer to a different object after initialization and we don't need * to access it's contents.

`const reference` <- don't modify this argument and don't waste time copying

### nullptr

Implemented to fix issues stemming from C due to the fact that `NULL` is simply `#define NULL 0`. This is pointer specific. 

A good example is:

```cpp
void f(int);
void f(void*);

f(NULL) // no idea which one this will call
f(nullptr) // will always call the void* impl.
```











