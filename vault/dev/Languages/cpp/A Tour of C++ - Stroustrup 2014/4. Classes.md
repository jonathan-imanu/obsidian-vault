**void memberFunction() const;** means that memberFunction will not modify the modify that it is called on.

**In constructors, all base classes and data members are fully initialized before the constructor body runs.**
### Destructors

A way to deallocate memory for classes

```cpp
class Toy {
private:
	double* elem;
	int sz;
public:
	Toy(int size) :elem{ new double[s]}, sz{size}
	{
		// init elem
	}
	~Toy() { delete []elem; } // <- the destructor
};
```

**The technique of acquiring resources in a constructor and releasing them in a destructor, known as Resource Acquisition Is Initialization or RAII**
### Concrete Types 

Behave just like built-in types. The `Toy` class above is a good example of a concrete type.
### Abstract Types 

Kinda like interfaces and abcs

```cpp
class Container {
public:
	virtual double& operator[](int) =0;
	virtual int size() const = 0;
	virtual ~Container() {}
}
```

`=0` means **pure virtual** meaning that a class derived from Container must define the function.

**It is the pure virtual function that makes Container abstract**

An class derived from Container would look like:

```cpp
class VectorContainer : public Container {
	// ...
} 
```

This type of structure lends itself nicely to polymorphism.

##### Difference between virtual and pure virtual

**Virtual**: A child class may override this and the base provides a default implementation

**Pure Virtual**: If a class contains a PV it can't be instantiated. PV don't have default implementations and child class MUST override. 
##### Virtual Function Table (vtbl)

Consider:

```cpp
class PureVirtual { 
public:
	virtual void func1() const =0;
}
class Child1 : public PureVirtual {
	// implements func1()
} 
class Child2 : public PureVirtual {
	// implements func1()
}

void use(&PureVirtual pv) {
	pv.func1();
	return;
}
```

If you call `use()` with a `Child1` how would it know which function to call when it only sees the abstract class?

Enter vtbl: The compiler will convert the name of a virtual function into an index into a table of pointers to functions. 

The vtbl allows the virtual function call mechanism to be made almost as efficient as a 'normal' function call. 

There is a space overhead of one pointer in each object of a class with virtual functions AND 1 vtbl for each such class.

#### Copying & Moving Containers

Objects can be copied by default. They will be member wise copied. 

We can choose the semantics of copying though. In particular, for classes that control a object accessed through a pointer the default memberwise copy would led to funky behavior. 

```cpp
...
class Something {
public:
	// Copying
	Something(const Something &smth);
	Something& operator=(const Something& smth);
	
	// Moving
	Something(Something &&smth);
	Something& operator=(Something&& smth)
	
};
```

#### Aside: const as a type augment

Use when you don't need to modify the object passed to function. There are two ways to do this:

```cpp
void function(const SomeType s); // Copies s, function never sees the og SomeType
void function(const &SomeType s); // Passes a reference to s
```

#### &&: 'rvalue reference'

'rvalue' is a term intended to complement 'lvalue' which means something that can appear on the left-hand side of an assignment.

There are five situations in which an object is copied or moved: 

1. As the source of an assignment 
2. As an object initializer 
3. As a function argument
4. As a function return value 
5. As an exception 

In all cases, the copy or move constructor will be applied (unless it can be optimized away). In addition to the initialization of named objects and objects on the free store, constructors are used to initialize temporary objects and to implement explicit type conversion

### Suppressing Operations

Using the default version of copy or move in a derived class might not be what we want or if we want to prevent a child from accessing a method defined in a parent class:

```cpp
class Child1 {
public:
	Child1(const Child& c) =delete; 
};
```

`=delete` is what deletes the op







`