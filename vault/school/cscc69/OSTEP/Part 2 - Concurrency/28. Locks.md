**A variable that holds a state-either unlocked or locked (it holds more information, of course, but as users we only need to care about this).**
### Evaluating Locks

We should care about three things when evaluating implementation of a lock:
1. Does it provide mutual exclusion
2. Does each thread contending for the lock get a fair shot at acquiring it once it's free? No thread should starve while waiting to obtain a lock.
3. Is it performant?
### Supporting Hardware

##### test-and-set

The simplest bit of hardware support to understand is known as a **test-and-set (or atomic exchange)** instruction. 
- It is the locked version of the atomic exchange (`xchg`) on `x86`

The **test-and-set** instr. `TestAndSet(int *old_ptr, int new)` returns the old value pointed to by the `old_ptr` and updates it to `new`
- Why does this work but a simple sequence of swaps or loads doesn't?
	- Everything is performed **atomically**!
##### compare-and-swap

Another hardware primitive is the **compare-and-swap** instruction (called **compare-and-exchange** on `x86`) 

`CompareAndSwap(&lock->flag, 0, 1)` tests whether the value at the address specified by ptr is equal to expected; if so, update the memory location pointed to by ptr with the new value. Always return the original value at that memory location.
##### fetch-and-add

Automatically increment a value while returning the old value at a particular address.
## yield

So we don't waste CPU clock cycles with code like this:

```C
void lock() { 
	while (TestAndSet(&flag, 1) == 1) 
		// spin
}
```

Recall that a thread can either be running, ready or blocked. `yield()` is a system-call that moves us **running** to **ready**: the yielding thread **deschedules** itself.

This isn't perfect though so we can waste lots of time context-switching until we find the context that actually holds the lock.
### Support from the OS

##### Futex on Linux

TODO!


