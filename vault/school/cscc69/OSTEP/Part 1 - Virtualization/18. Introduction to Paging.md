Instead of variable sized segments, paging is all about *fixed sized units called pages*. We correspondingly view physical memory as fixed-sized slots called page frames where each frame contains a single virtual-memory page.

The OS will maintain a *per process* data-structure called a **page table** that will store **address translations** for each of the virtual pages of the address space to let you know where in physical memory each page resides.

To translate a virtual address:
1. Split it into the **virtual page number (VPN)** and the **offset**
	1. The exact number of bits of the offset and the VPN will depend on the page number per process and the address space
2. Use the **page table** to get the **physical frame number (PFN) / physical page number (PPN)**

![[OSTEP Figure 18.3 - The Address Translation Process.png]]
### Page Table Structure

Simplest implementation is a **linear page table** which is just an array that can be indexed by the VPN to get the page table entry and find the PFN. 

Each PTE would have:
- **IMPORTANT** - A valid bit that indicates whether a certain translation is valid. 
	- If process accesses invalid memory, a trap will be generated that will likely terminate the process
- Present Bit indicates whether page is in memory or disk (has it been swapped out)
- Dirty bit that indicates whether page has been modified
- Reference Bit to track whether a page has been accessed
### Problems
- This approach takes up a lot of memory
	- 4KB page size means the offset needs to be at least 12 bits and the VPN would be the remaining 20 bits in a 32-bit address space
		- `VPN = total bits - offset bits`
		- `offset bits = based on page size`
	- THEN if we need 4 bytes per **page table entry** for the PPN + some other useful stuff, memory per process becomes 4MB!
- This approach is slow
	- Address translation is performed entirely using the page table stored in main memory.



