A TLB is part of the chipâ€™s memory-management unit (MMU), and is simply **a hardware cache of popular virtual-to-physical address translations.** TLB's rely on *temporal and spatial locality*. 

Upon each virtual memory reference, the hardware first checks the TLB to see if the desired translation is held therein
	- If yes: the translation is performed (quickly) without having to consult the page table (which has all translations). 
	- If no, it could either be handled by the hardware or the software.
		- Older systems would use hardware. 
			- It would have complex instruction sets and it would have to know exactly where page tables are in memory (with a page table register). 
		- Newer architectures would use software-managed TLB.
			- On TLB-miss, hardware raises an exception which sets privilege level to kernel mode and jumps to a trap handler.
			- This trap handler will run privileged instructions to update the TLB.
		- **Software based TLBs are more flexible and simple.** 
##### TLBs are only valid for the current process!
### Context Switching

When context switching, the OS must be careful about the TLB to ensure that the new process does not use translations that were applicable to previous process. 

To rectify, we can:

1. Flush the TLB by setting the valid bit of each entry to 0. Of course, there will then be TLB misses when a process first starts up.
2. Hardware provides a **address space identifier (ASID)** (like a PID but with less bits) in the TLB. Now there's no need to flush and since some pages could be shared among processes, we can take advantage of this.

Replacement Policy can be LRU based or random.
#### TLB Contents

TLB might be **fully associative** which means that OS will have to search all page table entries. A TLB entry might contain `VPN | PFN | protection bits | other bits`. Protection bits will determine how the page can be accessed. 

![[OSTEP Figure 19.4 - MIPS TLB Entry.png]]