**An abstraction provided by the operating system of a running program** 

> We have a lot more running programs than available CPUs, how can the OS create the illusion of an endless supply?
# Definitions

**Mechanisms**: Low-level machinery. Low-level methods and protocols that implement some piece of functionality. 
**Machine State**: What a program can read or update whilst it's running
**Address Space**: The memory that a process can address
### Time Sharing (of the CPU)

By running one process, stopping it and then running another - and repeating this for a large number of processes - the OS makes it seem like we have loads of *virtual* CPUs.

The benefit is that we can run many concurrent processes at once. Of course, the obvious drawback is performance, each program will run more slowly depending on the process to cpu ratio.
#### Going from program to process

Before execution program is simply a sequence of instructions together with the data stored in disk.

![[Screenshot 2026-01-02 at 1.21.26 PM.png]]

1. Add an entry for this process in the process list
2. Load program code and any static data into memory, into the process address space
	1. The OS does this lazily with **paging** and **swaping**
3. Allocate memory for the program's run-time stack and (maybe) heap
4. Start the program at it's entry point
#### Process States

1. **Running:**  Process is running on a processor and executing instructions
2. **Ready**: OS decided not to run for some reason
3. **Blocked**: Process does some kind of operation (such as file I/O) that means it can't run until some other event happens

#### Process List

A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process control block (PCB), which is really just a structure that contains information about a specific process.