> Consider the time-sharing virtualization model presented in [[4. The Process]]:
>  - How would we implement this without adding excessive system overhead?
>  - How can we (the OS) run processes efficiently whilst maintaining control over the CPU?

TLDR: The OS baby-proofs the CPU with trap handlers and an interrupt timer. The babies are processes.
#### The Basics of LDE

The simple approach of just "Run the program directly on the CPU" means we don't actually have control of anything and work more like a library than an actual OS.

Here are the problems:
1. Restricted Operations can be performed
2. Switching between processes
	1. How can the OS switch between processes if it doesn't have control of the CPU
##### 1. Allowing Processes to run Restricted Operations Whilst Maintaining Control

- Run processes in `user mode` by default
	- In contrast, we (the OS) run in `kernel mode`
		- `Kernel mode` means that OS has full access to hardware
		- `User mode` means that program does not have full access to hardware
- To perform some privileged operation, processes can use *system calls* 
	- Uses the `trap` and the `return-from-trap` instructions mentioned in [[Introduction to Operating Systems]]
	- To avoid clobbering the calling processes registers, on x86, the processor pushes PC, flags and some registers into a per-process kernel stack. The `return-from-trap` restores these

> The `trap` raises another issue: *How do we know what code is to run inside of the OS?*

The solution is a **trap table** set up by the kernel at boot time (when a machine boots up it's in `kernel mode`.
##### 2. Switching Between Processes

**Cooperative Approach**:  The OS "trusts" the process to behave reasonably. A process would transfer control by making system calls or when they do something illegal.
- Used by older systems
- Has the obvious drawback that evil processes can just hold on to the CPU forever
**Non-Cooperative Approach**: Use *timer interrupts* that raise every so many milliseconds so that, when raised, a pre-configured *interrupt handler* in the OS can run and regain control of the CPU
- Similar to the `trap` and `return-from-trap` we have to avoid clobbering the registers and state of the currently running program so that we can easily resume

After we regain CPU control, we can either switch to a new process or continue running the current one (this is decided by the OS's scheduler).

If we switch, OS executes a **context-switch**:
1. Save the register values for the currently executing process into kernel stack
2. Restore register values for the soon to be executing process
Now when we `return-from-trap`, the new switched in process starts








