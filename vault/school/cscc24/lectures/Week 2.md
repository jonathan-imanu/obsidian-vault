# Grammars

*A good chunk of this week was review from weeks 7 & 8 of b36. Didn't take notes on those slides, refer to b36-review*

Remember from B36, that **grammars** generate a language.
### Regular Grammars

More restrictive than CFGs. They are limited to productions of the form:

- **Left-recursive Grammar**: At most one non-terminal and it appears as the left-most symbol in the string on the RHS of the production rule.

```
<S> ::= <T> a b
<T> ::= a | <T> b
```

- **Right-recursive Grammar**: At most one non-terminal and it appears as the right-most symbol in the string on the RHS of the production rule

```
<S> ::= a <T>
<T> ::= b <T> | a b
```

### Extended BNF

The CFGs we've encountered are in **Backus-Naur Form**. There are extensions to BNF that make it more concise BUT NOT more powerful.
- EG `[ blah ]` denotes that `blah` is optional
- There is no standard EBNF
### derivation

*Also B36 review*

A derivation of string $s$ is the sequence of applications of production rules that generate $s$.
- A string is in the language generated by a grammar iff there is a derivation for it
### Parse Tree

A **parse tree** is a tree in which:
- the root is the start symbol
- every leaf is a terminal, and
- every internal node is a non-terminal, and its children correspond, in order, to the RHS of one of its productions in the grammar.

If we have multiple parse trees for a given string then we have an ambiguous language. 
## Ambiguity

A grammar is ambiguous iff it generates a string for which there are two or more distinct parse trees.

A string is ambiguous with respect to a grammar iff that grammar generates two or more distinct parse trees for the string.

**Tutorial Comment:** A red flag for ambiguity in CFG's is one production becoming two of itself.
### Adding Precedence

When changing a grammar to include precedence, we want the operations with lower precedence to appear closer to the root of the parse tree. Higher precedence operations should appear closer to the leaves.
##### How to actually do this?

We can do this with "chaining" the weaker ops to the next stronger one:

```
<expn> --> <expn> <add-op> <expn> | <mult-exp>
<mult-exp> --> <mult-exp> <mult-op> <mult-exp> | <pow-exp>
<pow-exp> --> <pow-exp> ^ <pow-exp> | <br-exp>
<br-exp> --> (<expn>) | <simple>
<simple> --> <identifier> | <literal>
<add-op> --> + | -
<mult-op> --> * | /
```

Notice how addition "chains" to multiplication which then "chains" to power and so on.
- **This is an incorrect grammar since it isn't associative** 
### Adding Associativity

For left-associative operators, put the recursive term before the non-recursive term in a production rule. For right-associative operators, put it after



