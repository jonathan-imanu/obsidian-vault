# Context-free Grammars

A general mechanism for describing how to generate strings. It is specified as a list of so-called productions.

Formally, a CFG is a tuple $G = (V, \sum, P, S)$ where $V$ is a set of variables, $\sum$ is a set of terminals, $P$ is a set of productions, and $S$ is a particular element of $V$, called the start symbol. 
- It must be the case that $V \cap \sum = \emptyset$
- $\forall p \in P$, $p$ has the form $A \rightarrow \alpha$ 

Derivations in $G$ are defined based on the relation $\rightarrow_{G}$ 
- We say $\alpha, \beta \in (V \cup \sum)^*, \alpha \rightarrow_{G} \beta \iff \alpha = \alpha_1A\alpha_2, \beta = \alpha_1C\alpha_2$ where 
	- $A \rightarrow C$ is a production and $\alpha_1, \alpha_2 \in (V \cup \sum)^*$

Given a CFG $G = (V, \sum, P, S)$, **$L(G)$ is the language generated by $G$.** We say that it is the set of all strings of terminals that can be derived from the start symbol of $G$.
- $L(G) = \{ x \in \sum^* : S \rightarrow_{G}^{*} x\}$
	- if a language $L$ can be represented in this way it is a *context-free language (CFL)*
##### CFG's are more powerful than regular expressions

*For every regular expression $R$ there is a CFG $G$ such that $L(G) = L(R)$* 
## Right-linear grammars and regular languages

A CFG $G = (V, \sum, P, S)$ is **right-linear** if every production in $P$ is of the form $A \rightarrow \epsilon$ or $A \rightarrow xB$ where $A, B \in V$ and $x \in \sum^*$. 
- The RHS of every production is the empty string OR a string of terminals followed by a single variable

*Right-linear CFGs generate **exactly** the set of regular expressions*

A **strict right-linear** language also has the property that $|x| \leq 1$ 
- The variable on the RHS (the $B$ in $A \rightarrow xB$) is preceded by an empty string or single terminal 
	- Equivalently the $x$ in $A \rightarrow xB$ is an empty string or single terminal

 **The languages generated by strict right-linear grammars CFGs are regular**
# Pushdown Automata

The automata that can accept CFLs.

It is a FSA augmented with a stack as auxiliary storage. This allows it to overcome the limitations (only remembering a finite number of things) of traditional FSAs since the size of the stack is unbounded.

A **pushdown automaton (PDA)** is a tuple $M = (Q, \sum, \gamma, \delta, q_0, F)$ where
- $Q$ is the finite nonempty set of states
- $\sum$ is the finite set of input symbols
- $\gamma$ is the finite set of stack symbols
- $q_0 \in Q$ is the start state
- $F \subseteq Q$ is the set of accepting states
	- $\delta$ is the transition function $\delta: Q \times (\sum \cup \{ \epsilon \}) \times (\gamma \cup \{ \epsilon \}) \rightarrow P(Q \times (\gamma \cup \{ \epsilon \}))$
	- $\delta$ maps to a state, an input symbol and a stack symbol to a set of pairs each consisting of a stack and stack symbol. 


 