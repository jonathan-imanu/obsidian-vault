**Difficulty:** Easy

Solved in under a minute w/ loops:

```python
# O(log n)
def isPowerOfTwo(n: int) -> bool:	
	if n < 1 or n % 2 == 1:
		return False
	i = 1
	while i < n:
		i *= 2
	return i == n
```

The follow up was:

"Solve it w/o loops or recursion"

I had no idea how to do this. The answer is bit manipulation and bit related activities.

### Solution 1

**Intution**

Recall in binary notation, that a power of two would always have exactly 1 bit w/ the rest being 0's. For ex:

`16 -> 10000`

Subtracting one would have it be flipped:

`15 -> 01111`

Now notice if we do

`n & (n - 1)` we get 0!

This is only if n is a power of two because subtraction wouldn't flip the bits of `n - 1` unless it was power!

But why does this work for 0? The answer is [Two's Complement Representation](obsidian://open?vault=vault&file=dev%2Fleetcode%2FConcepts%2FBits%2FConcepts)










