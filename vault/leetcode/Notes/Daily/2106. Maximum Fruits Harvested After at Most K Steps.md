Difficulty: Hard

**Status**: **Had no idea how to solve :(**

## **New Concept**: Prefix Sums:

What: A running total of a list of numbers

- EX: `amounts = [2, 5, 3, 7, 1]` has `prefix_sum = [0, 2, 7, 10, 17, 18]`

Why: Once you have the prefix sum array, you can **instantly** calculate the total amount between any two positions in the array using subtraction.

**Why use a leading 0?**

Helps with edge cases. The default in LC according to chat.

**When to use?**

- You need to query or compare values over many ranges.
- The data is static or updated in batches.
- Youâ€™re looking for O(1) range queries after preprocessing.

## Solution 

Consider:

`fruits = [[2,8],[6,3],[8,6]]`

Can we travel from i position of fruits to j position of fruits from startPos? Answering this question for all possible i & j leads to the solution!

```python
def maxTotalFruits(fruits, start, k):
	max_fruits = 0
	
	pos = [item[0] for item in fruits]
	amounts = [item[1] for item in fruits]
	prefix_sum = [0]
	
	for amount in amounts:
		prefix_sum.append(prefix_sum[-1] + amount)

	i = 0
	for j in range(len(pos)):
		if i <= j and not canTravel(i , j):
			i += 1 # tighten the window size
		max_fruits = max(max_fruits, prefix_sum[j + 1] - prefix_sum[i])
	return max_fruits
```

Key Learnings:

- Sliding Window doesn't always have to be from the startPos to the end position. In a problem like this where we are constrained by some cost function AND can double back, we can say:
	- Can we cover all the distance from some position to another position from the start position without going over the cost!
- The key 'trick' here comes from the `canTravel` function. 
	- From `startPos` if we want to cover the distance from `pos[i] to pos[j]` there are four ways of doing so:
		- if `pos[i]` is larger than `startPos` then all we can do is go right
		- sym. argument for `pos[j`
		- Where it gets interesting is if `pos[i] <= startPos <= pos[j]`. We can do one of two things:
			- Go left to `pos[i]` then go right (crossing `startPos`) to `pos[j]`
			- Go right to `pos[j]` then go left (crossing `startPos`) to `pos[i]`
	- What we want is a simple way to calculate this:

```python
# Pre: from loop cond. we have gurantee that i <= j
def canTravel(i, j):
	left = pos[i]
	right = pos[j]	
	travel_distance = right - left
	return min(abs(startPos - right) + travel_distance, 
			   abs(startPos - left) + travel_distance) <= k
```

- We don't care about the path! Just whether or not we can travel it!


